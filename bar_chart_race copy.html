<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Disney Bar‐Chart Race with Large Icon Controls</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      overflow: hidden;
    }
    #chart {
      position: relative;
    }
    .bar {
      fill-opacity: 0.8;
    }
    .bar:hover {
      fill-opacity: 1;
    }
    .label {
      font-size: 16px;
      fill: #000;
      text-anchor: start;
      pointer-events: none;
    }
    .year-text {
      font-size: 80px;
      fill: #ddd;
      text-anchor: end;
    }
    .axis .domain,
    .axis line {
      display: none;
    }
    .axis text {
      font-size: 16px;
    }

    /* Tooltip */
    .tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(255,255,255,0.9);
      padding: 6px 10px;
      border: 1px solid #aaa;
      border-radius: 4px;
      font-size: 24px;
      color: #333;
      display: none;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
    }

    /* Controls container */
    #controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin: 10px;
    }

    /* Large icon button */
    #play-pause {
      background: none;
      border: none;
      padding: 2px;      /* larger click area */
      cursor: pointer;
    }

    #stop {
      background: none;
      border: none;
      padding: 2px;      /* larger click area */
      cursor: pointer;
    }

    /* Slider */
    /* #year-slider {
      width: 60%;
    } */
        /* New slider-group styling */
    .slider-group {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .slider-group label {
      font-size: 14px;
      margin-bottom: 4px;
    }
    .slider-group input {
      width: 600px;
    }
      /* style for the min/max labels under each slider */
  .slider-coords {
    display: flex;
    justify-content: space-between;
    width: 600px;   /* match the slider width */
    font-size: 12px;
    margin-top: 4px;
    color: #666;
  }
  </style>
</head>
<body>
  <div id="chart"></div>
  clearCanvas();


  <script src="d3.v7.min.js"></script>
  <script>
    const margin = { top: 50, right: 200, bottom: 100, left: 50 };
    const width  = 900 - margin.left - margin.right;
    const height = 500 - margin.top - margin.bottom;

    const svg = d3.select('#chart')
      .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
      .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    const tooltip = d3.select('#tooltip');

    d3.csv('disney_movies_total_gross_chinese_annotated.csv', d => ({
      title:        d.movie_title,
      year:         new Date(d.release_date).getFullYear(),
      gross:        +d.total_gross.replace(/[$,]/g, ''),
      release_date: d.release_date,
      genre:        d.genre,
      mpaa:         d.MPAA_rating,
      total_gross:  d.total_gross,
      inflation_adjusted_gross:  d.inflation_adjusted_gross,
      annotation:   d.annotation   // <-- new field
    })).then(data => {
      data = data.filter(d => !isNaN(d.year) && !isNaN(d.gross));
      const years = Array.from(new Set(data.map(d => d.year))).sort((a,b)=>a-b);

      let cumulative = years.map(year=>({
        year,
        movies: data
          .filter(d=>d.year<=year)
          .sort((a,b)=>b.gross-a.gross)
          .slice(0,10)
      }));

      const maxGross = d3.max(cumulative, d=>d3.max(d.movies,m=>m.gross));
      const x = d3.scaleLinear([0,maxGross],[0,width]);
      const y = d3.scaleBand()
        .domain(d3.range(10))
        .range([0,height])
        .padding(0.1);

      // Top axis
      svg.append('g')
        .attr('class','axis')
        .call(d3.axisTop(x)
          .ticks(width/100)
          .tickFormat(d=>'$'+d3.format('.2s')(d).replace('G','B'))
        );

      const yearLabel = svg.append('text')
        .attr('class','year-text')
        .attr('x', width)
        .attr('y', height - 10)
        .text('');

      // const color = d3.scaleOrdinal(d3.schemeTableau10);
      // no explicit domain here
      const color = d3.scaleOrdinal()
      .range(d3.schemeTableau10);

      // let yearIndex = 0, isPlaying = true, interval;
      // const playButton = d3.select('#play-pause'),
      //       icon       = d3.select('#play-pause-icon');

      // playButton.on('click', () => {
      //   if (isPlaying) {
      //     stop();
      //     icon.attr('src','play.png').attr('alt','Play');
      //   } else {
      //     start();
      //     icon.attr('src','pause.png').attr('alt','Pause');
      //   }
      //   isPlaying = !isPlaying;
      // });

      // const slider = d3.select('#year-slider')
      //   .attr('max', cumulative.length-1)
      //   .on('input', function(){
      //     yearIndex = +this.value;
      //     update(cumulative[yearIndex]);
      //   });

            // ▶▶ REPLACED: dual-slider + bounded playback logic

      const svgNode   = svg.node();
      const svgWidth  = width;
      const svgHeight = height;

      // 2) reserve a little strip at the bottom for controls
      const controlHeight = 50;

      // 3) append a foreignObject container
      const fo = svg.append('foreignObject')
        .attr('x',      0)
        .attr('y',      svgHeight + controlHeight-15)
        .attr('width',  svgWidth)
        .attr('height', controlHeight);

      const controls = fo.append('xhtml:div')
        .style('display',        'flex')
        .style('align-items',    'center')
        .style('justify-content','flex-start')
        .style('height',         `${controlHeight}px`)
        .style('padding',        '0 10px')
        .style('font-family',    'sans-serif');

      // 3) add the Play button
      controls.append('button')
        .attr('id', 'play-pause')
        .style('margin-left', '30px')
        .style('margin-right', '2px')
        .style('font-size',    '16px')
        .style('cursor',       'pointer')
        .style('opacity', 0.8)
        .append('img')
          .attr('id', 'play-pause-icon')
          .attr('src', 'pause.png')
          .attr('alt', 'Pause')
          .style('width', '30px')  // Adjust size as needed
          .style('height', '30px'); // Adjust size as needed

      controls.append('button')
        .attr('id', 'stop')
        .style('margin-left', '10px')
        .style('margin-right', '20px')
        .style('font-size',    '16px')
        .style('cursor',       'pointer')
        .style('opacity', 0.8)
        .append('img')
          .attr('id', 'stop-icon')
          .attr('src', 'stop.png')
          .style('width', '30px')  // Adjust size as needed
          .style('height', '30px'); // Adjust size as needed

      //// 4) inside it, create an XHTML <div> flexbox to hold two groups
      //const controls = fo.append('xhtml:div')
      //  .style('display',        'flex')
      //  .style('justify-content','space-around')
      //  .style('align-items',    'center')
      //  .style('height',         `${controlHeight}px`)
      //  .style('font-family',    'sans-serif');

      // 5) for each of “start” and “end”, append a label, a range input, and a span for the current-year
      ['start','end'].forEach(name => {
        const isStart    = name === 'start';
        const defaultIdx = isStart ? 0 : cumulative.length - 1;
        const group      = controls.append('div').style('text-align','center');

        group.append('label')
            .attr('for', `${name}-slider`)
            .style('margin-right','8px')
            .text(isStart ? 'Start Year:' : 'End Year:');

        group.append('input')
            .attr('type',  'range')
            .attr('id',    `${name}-slider`)
            .attr('min',   0)
            .attr('max',   cumulative.length - 1)
            .style('accent-color', '#007FFF')
            .style('margin-right', '20px')
            .style('margin-top', '12px')
            .property('value', defaultIdx);

        group.append('div')
            .append('span')
            .attr('id',   `${name}-current`)
            .style('font-weight','bold')
            .text(years[defaultIdx]);
      });

      // 6) set up your index vars
      let startIndex = 0;
      let isPlaying  = true;
      let endIndex   = cumulative.length - 1;
      let current    = startIndex;

      // 7) wire up the two sliders exactly as before, but now update the dynamically-created spans
      const startSlider = d3.select('#start-slider');
      const endSlider   = d3.select('#end-slider');

      startSlider.on('input', function() {
        const idx = +this.value;
        startIndex = idx;

        // clamp end
        if (startIndex > endIndex) {
          endIndex = startIndex;
          endSlider.property('value', endIndex);
          d3.select('#end-current').text(years[endIndex]);
        }

        // update chart & label
        current = startIndex;
        update(cumulative[current]);
        d3.select('#start-current').text(years[startIndex]);
      });

      endSlider.on('input', function() {
        const idx = +this.value;
        endIndex = idx;

        // clamp start
        if (endIndex < startIndex) {
          startIndex = endIndex;
          startSlider.property('value', startIndex);
          d3.select('#start-current').text(years[startIndex]);
        }

        // rewind chart if beyond end
        if (current > endIndex) {
          current = endIndex;
          update(cumulative[current]);
        }

        // update label
        d3.select('#end-current').text(years[endIndex]);
      });

      const playButton  = d3.select('#play-pause'),
      icon        = d3.select('#play-pause-icon');
      const stopButton  = d3.select('#stop');

      // Replace your old single‐slider input handler with play/pause wiring:
      playButton.on('click', () => {
        if (isPlaying) {
          stop();
          icon.attr('src','play.png').attr('alt','Play');
        } else {
          if (current >= endIndex){
            console.log('current:', current);
            current = startIndex;
          }
          start(1000);
          icon.attr('src','pause.png').attr('alt','Pause');
        }
        isPlaying = !isPlaying;
      })
      .on('mouseover', () => {
        d3.select('#play-pause')
          .style('cursor', 'pointer')
          .style('opacity', 1);
      })
      .on('mouseout', () => {
        d3.select('#play-pause')
          .style('cursor', 'default')
          .style('opacity', 0.8);
      })

      // ◀◀ end replacement ◀◀


      function update(frame) {
        // ① make sure our scale only knows about *this* year’s titles
        color.domain(frame.movies.map(d => d.title));
        const t = svg.transition().duration(500);
        const movies = frame.movies;

        // BARS
        const bars = svg.selectAll('.bar')
          .data(movies, d=>d.title);

        bars.exit()
          .transition(t)
          .attr('width',0)
          .remove();

        const barsEnter = bars.enter().append('rect')
          .attr('class','bar')
          .attr('x',0)
          .attr('height',y.bandwidth())
          .attr('y',(_,i)=>y(i))
          .style('fill',d=>color(d.title))
          .on('mouseover',(event,d)=>{
            tooltip.style('display','block')
                   .html(`
                     <strong>${d.title}</strong><br/>
                     出品日期: ${d.release_date}<br/>
                     类型: ${d.genre}<br/>
                     评级: ${d.mpaa||'N/A'}<br/>
                     总票房: ${d.total_gross}<br/>
                     通胀调整后票房: ${d.inflation_adjusted_gross}<br/>
                     简介: ${d.annotation}     <!-- added 简介 -->
                   `);
          })
          .on('mousemove',event=>{
            tooltip.style('left', (event.pageX+10)+'px')
                   .style('top',  (event.pageY+10)+'px');
          })
          .on('mouseout',()=>{
            tooltip.style('display','none');
          });

        // barsEnter.merge(bars)
        barsEnter.merge(bars)
          .transition(t)
          .attr('y',(_,i)=>y(i))
          .attr('width',d=>x(d.gross))
          .style('fill', d=>color(d.title));  

        // LABELS
        const labels = svg.selectAll('.label')
          .data(movies, d=>d.title);

        labels.exit().remove();

        const labelsEnter = labels.enter().append('text')
          .attr('class','label')
          .attr('y',(_,i)=>y(i)+y.bandwidth()/2+5)
          .attr('x',d=>x(d.gross)+5)
          .text(d=>`${d.title} (${d.year})`);

        labelsEnter.merge(labels)
          .transition(t)
          .attr('y',(_,i)=>y(i)+y.bandwidth()/2+5)
          .attr('x',d=>x(d.gross)+5)
          .text(d=>`${d.title} (${d.year})`);

        // YEAR TEXT
        yearLabel.transition(t).text(frame.year);

        // sync slider
        // slider.property('value', yearIndex);
      }
      
      stopButton.on('click', () => {
        if (isPlaying) {
          stop();
          icon.attr('src','play.png').attr('alt','Play');
          start(0);
        } 
        isPlaying = false;
      })
      .on('mouseover', () => {
        d3.select('#stop')
          .style('cursor', 'pointer')
          .style('opacity', 1);
      })
      .on('mouseout', () => {
        d3.select('#stop')
          .style('cursor', 'default')
          .style('opacity', 0.8);
      })

      // function start(){
      //   interval = d3.interval(()=>{
      //     if (yearIndex < cumulative.length-1) {
      //       yearIndex++;
      //       update(cumulative[yearIndex]);
      //     } else {
      //       stop();
      //       icon.attr('src','play.png').attr('alt','Play');
      //       isPlaying = false;
      //     }
      //   }, 1000);
      // }

      let currentStartIdx = startIndex;
      function start(t){
        interval = d3.interval(()=>{
       // advance only up to endIndex
       if (currentStartIdx !== startIndex) {
         //update cumulative
         currentStartIdx = startIndex;
         cumulative = years.map(year=>({
            year,
            movies: data
              .filter(d=>d.year<=year && d.year>=years[currentStartIdx])
              .sort((a,b)=>b.gross-a.gross)
              .slice(0,10)
          }));
          console.log(years[currentStartIdx]);
          console.log(cumulative);
          
       }
       if (current < endIndex) {
        if (t == 0){
          current = endIndex;
          update(cumulative[current]);
          stop();
        }
        else{
          current++;
          update(cumulative[current]);
        }
       } else {
         stop();
         icon.attr('src','play.png').attr('alt','Play');
         isPlaying = false;
       }
     }, t);
   }


      function stop(){
        if (interval) interval.stop();
      }

    // init + autoplay
    update(cumulative[current]);
    start(1000);
    })
    .catch(err=>console.error(err));
  </script>
</body>
</html>
