<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Disney Genres Scatter Plot with Interactive Genre List</title>
  <style>
    body { font-family: sans-serif; margin: 0; overflow: hidden; }
    svg { display: block; margin: auto; }
    .axis path, .axis line { stroke: #aaa; }
    .axis text { font-size: 12px; }
    .legend { font-size: 12px; fill: #333; }
    .hover-label { font-size: 12px; fill: #000; font-weight: bold; text-anchor: middle; }
    .genre-item rect { fill: #f5f5f5; stroke: #ccc; rx: 4; ry: 4; }
    .genre-item text { font-size: 12px; fill: #333; pointer-events: none; }
    .genre-item:hover rect { fill: #e0e0e0; cursor: pointer; }
  </style>
</head>
<body>
  <svg id="chart"></svg>

  <script src="d3.v7.min.js"></script>
  <script>
  // CONFIG
  const margin = { top: 60, right: 300, bottom: 60, left: 200 };
  const width  = 800 - margin.left - margin.right;
  const height = 500 - margin.top  - margin.bottom;

  // SVG CANVAS
  const svg = d3.select("#chart")
    .attr("width",  width + margin.left + margin.right)
    .attr("height", height + margin.top  + margin.bottom)
    .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

  // LOAD & PREPROCESS
  d3.csv("disney_movies_total_gross.csv").then(raw => {
    // normalize ratings and parse
    raw.forEach(d => {
      let r = d.MPAA_rating;
      if (!r || r === "Unrated" || r === "Not Rated") r = "Not Rated";
      d.rating = r;
      d.genre = d.genre || "Unknown";
      d.gross = +d.inflation_adjusted_gross.replace(/[$,]/g, "");
    });

    // rating categories & colors
    const allRatings = Array.from(new Set(raw.map(d => d.rating))).sort();
    const colorRating = d3.scaleOrdinal(d3.schemeSet3).domain(allRatings);

    // compute per-genre aggregates
    const dataMap = d3.rollups(
      raw.filter(d => d.genre && !isNaN(d.gross)),
      v => ({ count: v.length, totalGross: d3.sum(v, d => d.gross), averageGross: d3.mean(v, d => d.gross) }),
      d => d.genre
    );
    let data = dataMap.map(([genre, stats]) => ({ genre, ...stats }));

    // breakdown by rating
    const genreRating = new Map(
      d3.rollups(
        raw.filter(d => d.genre && d.rating && !isNaN(d.gross)),
        v => d3.rollups(v, vv => d3.sum(vv, d => d.gross), d => d.rating),
        d => d.genre
      ).map(([g, arr]) => [ g, arr.map(([rating, sum]) => ({ rating, sum })) ])
    );

    // sort genres by totalGross descending for list
    const sortedData = [...data].sort((a,b) => b.totalGross - a.totalGross);

    // SCALES
    const x = d3.scaleLinear().domain([0, d3.max(data, d => d.count) * 1.1]).range([0, width]);
    const y = d3.scaleLinear().domain([0, d3.max(data, d => d.averageGross) * 1.1]).range([height, 0]);
    const maxGross = d3.max(data, d => d.totalGross);
    const color = d3.scaleSequential(d3.interpolateBlues).domain([0, maxGross]);
    const rScale = d3.scaleSqrt().domain([0, maxGross]).range([4, 20]);

    // AXES
    svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x).ticks(8))
      .append("text").attr("x", width/2).attr("y", 40).attr("fill", "#000").attr("text-anchor","middle").text("Number of Movies");
    svg.append("g").call(d3.axisLeft(y).ticks(8).tickFormat(d => "$"+d3.format(".2s")(d).replace("G","B")))
      .append("text").attr("transform","rotate(-90)").attr("x", -height/2).attr("y", -50).attr("fill","#000").attr("text-anchor","middle").text("Average Inflation-Adjusted Gross");

    // SCATTER LEGENDS
    const defs = svg.append("defs");
    const gradient = defs.append("linearGradient").attr("id","color-gradient").attr("x1","0%").attr("y1","0%").attr("x2","100%").attr("y2","0%");
    d3.range(0,1.01,0.1).forEach(t => gradient.append("stop").attr("offset",`${t*100}%`).attr("stop-color", color(t*maxGross)));
    const legendX = width + 20;
    const lg = svg.append("g").attr("transform", `translate(${legendX},0)`);
    const cbW = 150, cbH = 10;
    lg.append("text").attr("class","legend").attr("x",0).attr("y",20).text("Total Gross (color)");
    lg.append("rect").attr("x",0).attr("y",30).attr("width", cbW).attr("height", cbH).style("fill","url(#color-gradient)");
    lg.append("g").attr("transform",`translate(0,${30+cbH})`).call(d3.axisBottom(d3.scaleLinear().domain([0,maxGross]).range([0,cbW])).ticks(5).tickFormat(d=>"$"+d3.format(".2s")(d).replace("G","B")));
    const sizeY = 35 + cbH + 30;
    lg.append("text").attr("class","legend").attr("x",0).attr("y",sizeY).text("Total Gross (size)");
    const sizes = [maxGross*0.1, maxGross*0.5, maxGross];
    const sl = lg.append("g").attr("transform", `translate(0,${sizeY+20})`);
    sl.selectAll("circle").data(sizes).enter().append("circle").attr("cx",(d,i)=>i*60 + rScale(d)).attr("cy",0).attr("r",d=>rScale(d)).attr("fill",d=>color(d)).attr("stroke","#333");
    sl.selectAll("text.size-label").data(sizes).enter().append("text").attr("x",(d,i)=>i*60+rScale(d)).attr("y",d=>rScale(d)+15).attr("text-anchor","middle").text(d=>"$"+d3.format(".2s")(d).replace("G","B"));

    // INTERACTION FUNCTIONS
    const pieGroup = svg.append("g").attr("class","pie-group").style("pointer-events","none").style("opacity",0);
    const pieR = 60;
    const pieGen = d3.pie().value(d=>d.sum);
    const arcGen = d3.arc();

    function hoverOn(d) {
      // dim others
      circles.transition().duration(200).attr("opacity",0.15);
      const thisCircle = circles.filter(dd=>dd.genre===d.genre).raise();
      const newR = rScale(d.totalGross) * 1.5;
      thisCircle.transition().duration(200).attr("r", newR).attr("opacity",1);
      // inner pie
      const breakdown = genreRating.get(d.genre) || [];
      pieGroup.selectAll("*").remove();
      const cx = x(d.count), cy = y(d.averageGross);
      pieGroup.attr("transform", `translate(${cx},${cy})`);
      pieGroup.selectAll("path").data(pieGen(breakdown)).enter().append("path")
        .attr("d", arcGen.innerRadius(0).outerRadius(newR))
        .attr("fill", arcData=>colorRating(arcData.data.rating))
        .attr("stroke","#fff").attr("stroke-width",1)
        .style("opacity",0).transition().duration(500).style("opacity",1);
      pieGroup.raise().transition().duration(200).style("opacity",1);
      // hover label
      svg.selectAll(".hover-label").remove();
      svg.append("text").attr("class","hover-label").attr("x", cx).attr("y", cy - newR - 10)
        .text(`${d.genre}: ${d.count} movies, $${d3.format(",.0f")(d.averageGross)} avg`);
      // update static pie legend
      updateStaticPie(d.genre);
    }
    function hoverOff() {
      circles.transition().duration(200).attr("opacity",1).attr("r", d=>rScale(d.totalGross));
      pieGroup.transition().duration(500).style("opacity",0);
      svg.selectAll(".hover-label").remove();
    }

    // DRAW SCATTER
    const circles = svg.selectAll(".point").data(data, d=>d.genre).enter().append("circle").attr("class","point")
      .attr("cx", d=>x(d.count)).attr("cy", y(0)).attr("r",0)
      .attr("fill", d=>color(d.totalGross)).attr("stroke","#333").attr("stroke-width",1)
      .on("mouseover", (e,d)=>hoverOn(d))
      .on("mouseout", ()=>hoverOff());
    circles.transition().delay((d,i)=>i*100).duration(1000)
      .attr("cy", d=>y(d.averageGross)).attr("r", d=>rScale(d.totalGross));

    // VERTICAL GENRE LIST
    const listGroup = svg.append("g").attr("class","genre-list").attr("transform", `translate(${-margin.left+10},0)`);
    const itemHeight = 24;
    const genreItems = listGroup.selectAll(".genre-item").data(sortedData).enter().append("g").attr("class","genre-item")
      .attr("transform", (d,i)=>`translate(0,${i*itemHeight})`)
      .on("mouseover", (e,d)=>hoverOn(d))
      .on("mouseout", ()=>hoverOff());
    genreItems.append("rect").attr("width", margin.left-20).attr("height", itemHeight-4)
      .attr("rx",4).attr("ry",4);
    genreItems.append("text").attr("x",10).attr("y", itemHeight/2+4).text(d=>d.genre);

    // STATIC PIE LEGEND UNDER SCATTER LEGENDS
    const pieLegend = svg.append("g").attr("class","pie-legend").attr("transform", `translate(${legendX},${sizeY+120})`);
    function updateStaticPie(genre) {
      pieLegend.selectAll("*").remove();
      const breakdown = genreRating.get(genre) || [];
      // draw pie
      const pieX = 125, pieY = 0;
      const arcs = pieLegend.selectAll(".arc").data(pieGen(breakdown)).enter().append("path");
      arcs.attr("d", arcGen.innerRadius(0).outerRadius(pieR))
        .attr("transform", `translate(${pieX},${pieY})`)
        .attr("fill", d=>colorRating(d.data.rating))
        .attr("stroke","#fff").attr("stroke-width",1);
      // legend
      allRatings.forEach((r,i)=>{
        const row = pieLegend.append("g").attr("transform",`translate(0,${i*20+20})`);
        row.append("rect").attr("width",12).attr("height",12).attr("fill",colorRating(r));
        row.append("text").attr("x",18).attr("y",10).text(r);
      });
    }

  }).catch(err=>console.error(err));
  </script>
</body>
</html>
