<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Disney Genres Scatter Plot with Pie on Hover</title>
  <style>
    body { font-family: sans-serif; margin: 0; overflow: hidden; }
    svg { display: block; margin: auto; }
    .axis path, .axis line { stroke: #aaa; }
    .axis text { font-size: 12px; }
    .legend { font-size: 12px; fill: #333; }
    .tooltip { pointer-events: none; font-size: 14px; fill: #000; font-weight: bold; }
    .rating-legend text { font-size: 12px; fill: #333; }
  </style>
</head>
<body>
  <svg id="chart"></svg>

  <script src="d3.v7.min.js"></script>
  <script>
  // CONFIG
  const margin = { top: 60, right: 300, bottom: 60, left: 80 };
  const width  = 800 - margin.left - margin.right;
  const height = 500 - margin.top  - margin.bottom;

  // SVG CANVAS
  const svg = d3.select("#chart")
    .attr("width",  width + margin.left + margin.right)
    .attr("height", height + margin.top  + margin.bottom)
    .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

  // LOAD & PREPROCESS
  d3.csv("disney_movies_total_gross.csv").then(raw => {
    // normalize ratings: merge 'Unrated' and missing into 'Not Rated'
    raw.forEach(d => {
      let r = d.MPAA_rating;
      if (!r || r === "Unrated" || r === "Not Rated") r = "Not Rated";
      d.rating = r;
      d.genre = d.genre || "Unknown";
      d.gross = +d.inflation_adjusted_gross.replace(/[$,]/g, "");
    });

    // extract all unique ratings for consistent color mapping
    const allRatings = Array.from(new Set(raw.map(d => d.rating))).sort();
    const colorRating = d3.scaleOrdinal(d3.schemeSet3)
      .domain(allRatings);

    // per-genre stats
    const dataMap = d3.rollups(
      raw.filter(d => d.genre && !isNaN(d.gross)),
      v => ({
        count: v.length,
        totalGross: d3.sum(v, d => d.gross),
        averageGross: d3.mean(v, d => d.gross)
      }),
      d => d.genre
    );
    const data = dataMap.map(([genre, stats]) => ({
      genre,
      count: stats.count,
      totalGross: stats.totalGross,
      averageGross: stats.averageGross
    }));

    // genre -> rating breakdown
    const genreRating = new Map(
      d3.rollups(
        raw.filter(d => d.genre && d.rating && !isNaN(d.gross)),
        v => d3.rollups(v, vv => d3.sum(vv, d => d.gross), d => d.rating),
        d => d.genre
      ).map(([genre, arr]) => [
        genre,
        arr.map(([rating, sum]) => ({ rating, sum }))
      ])
    );

    // SCALES
    const x = d3.scaleLinear()
      .domain([0, d3.max(data, d => d.count) * 1.1])
      .range([0, width]);

    const y = d3.scaleLinear()
      .domain([0, d3.max(data, d => d.averageGross) * 1.1])
      .range([height, 0]);

    const maxGross = d3.max(data, d => d.totalGross);
    // improved heatmap
    const color = d3.scaleSequential(d3.interpolateBlues)
      .domain([0, maxGross]);

    const rScale = d3.scaleSqrt()
      .domain([0, maxGross])
      .range([4, 20]);

    // AXES
    svg.append("g")
      .attr("class","axis")
      .attr("transform", `translate(0,${height})`)
      .call(d3.axisBottom(x).ticks(8))
      .append("text")
        .attr("x", width/2)
        .attr("y", 40)
        .attr("fill","#000")
        .attr("text-anchor","middle")
        .text("Number of Movies");

    svg.append("g")
      .attr("class","axis")
      .call(d3.axisLeft(y).ticks(8)
        .tickFormat(d => "$" + d3.format(".2s")(d).replace("G","B"))
      )
      .append("text")
        .attr("transform","rotate(-90)")
        .attr("x", -height/2)
        .attr("y", -50)
        .attr("fill","#000")
        .attr("text-anchor","middle")
        .text("Average Inflation-Adjusted Gross");

    // COLOR GRADIENT legend
    const defs = svg.append("defs");
    const gradient = defs.append("linearGradient")
      .attr("id","color-gradient")
      .attr("x1","0%").attr("y1","0%")
      .attr("x2","100%").attr("y2","0%");
    d3.range(0,1.01,0.1).forEach(t => {
      gradient.append("stop")
        .attr("offset", `${t*100}%`)
        .attr("stop-color", color(t * maxGross));
    });

    // DRAW & ANIMATE CIRCLES
    const circles = svg.selectAll(".point")
      .data(data, d => d.genre)
      .enter().append("circle")
        .attr("class","point")
        .attr("cx", d => x(d.count))
        .attr("cy", y(0))
        .attr("r", 0)
        .attr("fill", d => color(d.totalGross))
        .attr("stroke","#333")
        .attr("stroke-width",1)
      .on("mouseover", function(event, d) {
        d3.select(this).transition().duration(200)
          .attr("r", rScale(d.totalGross) * 1.5);
        svg.selectAll(".tooltip").remove();
        svg.append("text").attr("class","tooltip")
          .attr("x", x(d.count))
          .attr("y", y(d.averageGross) - (rScale(d.totalGross)*1.5) - 10)
          .attr("text-anchor","middle")
          .text(`${d.genre}: ${d3.format("$,.0f")(d.averageGross)} avg`);
        showPie(d.genre);
      })
      .on("mouseout", function(event, d) {
        d3.select(this).transition().duration(200)
          .attr("r", rScale(d.totalGross));
        svg.selectAll(".tooltip").remove();
        hidePie();
      });
    circles.transition().delay((d,i)=>i*100).duration(1000)
      .attr("cy", d=>y(d.averageGross))
      .attr("r", d=>rScale(d.totalGross));

    // MAIN LEGENDS
    const legendX = width + 40;
    const lg = svg.append("g").attr("transform", `translate(${legendX}, 0)`);
    const cbW = 150, cbH = 10;
    const cbScale = d3.scaleLinear().domain([0, maxGross]).range([0, cbW]);
    lg.append("text").attr("class","legend").attr("x",0).attr("y",0)
      .text("Total Gross (color)");
    lg.append("rect").attr("x",0).attr("y",5)
      .attr("width", cbW).attr("height", cbH)
      .style("fill","url(#color-gradient)");
    lg.append("g").attr("transform",`translate(0,${5+cbH})`)
      .call(d3.axisBottom(cbScale).ticks(5)
        .tickFormat(d=>"$"+d3.format(".2s")(d).replace("G","B"))
      );
    const sizeY = 5+cbH+60;
    lg.append("text").attr("class","legend").attr("x",0).attr("y",sizeY)
      .text("Total Gross (size)");
    const sizes=[maxGross*0.1,maxGross*0.5,maxGross];
    const sl = lg.append("g").attr("transform",`translate(0,${sizeY+20})`);
    sl.selectAll("circle").data(sizes).enter().append("circle")
      .attr("cx",(d,i)=>i*60+rScale(d)).attr("cy",0)
      .attr("r",d=>rScale(d))
      .attr("fill",d=>color(d)).attr("stroke","#333");
    sl.selectAll("text.size-label").data(sizes).enter().append("text")
      .attr("x",(d,i)=>i*60+rScale(d)).attr("y",d=>rScale(d)+15)
      .attr("text-anchor","middle").text(d=>"$"+d3.format(".2s")(d).replace("G","B"));

    // PIE CHART GROUP under legends
    const pieGroup = svg.append("g").attr("class","pie-group")
      .style("opacity",0).style("pointer-events","none");
    const pieR=60, pieX=legendX+cbW/2, pieY=sizeY+200;
    const pie = d3.pie().value(d=>d.sum);
    const arcGen = d3.arc().innerRadius(0).outerRadius(pieR);

    function showPie(genre) {
      const breakdown = genreRating.get(genre) || [];
      pieGroup.selectAll("*").remove();
      pieGroup.attr("transform",`translate(${pieX},${pieY})`);
      // draw arcs with consistent colorRating
      const arcs = pieGroup.selectAll(".arc").data(pie(breakdown)).enter().append("g").attr("class","arc");
      arcs.append("path").attr("d",arcGen)
        .attr("fill",d=>colorRating(d.data.rating))
        .attr("stroke","#fff").attr("stroke-width",1)
        .style("opacity",0).transition().duration(500).style("opacity",1);
      pieGroup.append("text").attr("y",-pieR-10).attr("text-anchor","middle").attr("class","legend")
        .text(`${genre} by Rating`).style("opacity",0).transition().duration(500).style("opacity",1);
      // rating legend
      const legendR = pieGroup.append("g").attr("class","rating-legend").attr("transform",`translate(${pieR+20},${-pieR})`);
      allRatings.forEach((r,i)=>{
        const row=legendR.append("g").attr("transform",`translate(0,${i*20})`);
        row.append("rect").attr("width",12).attr("height",12).attr("fill",colorRating(r));
        row.append("text").attr("x",18).attr("y",10).text(r);
      });
      pieGroup.transition().duration(500).style("opacity",1);
    }
    function hidePie(){ pieGroup.transition().duration(500).style("opacity",0);}  

  }).catch(err=>console.error(err));
  </script>
</body>
</html>
