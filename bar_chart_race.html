<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Disney Bar‐Chart Race with Large Icon Controls</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      overflow: hidden;
    }
    #chart {
      position: relative;
    }
    .bar {
      fill-opacity: 0.8;
    }
    .bar:hover {
      fill-opacity: 1;
    }
    .label {
      font-size: 16px;
      fill: #000;
      text-anchor: start;
      pointer-events: none;
    }
    .year-text {
      font-size: 80px;
      fill: #ddd;
      text-anchor: end;
    }
    .axis .domain,
    .axis line {
      display: none;
    }
    .axis text {
      font-size: 16px;
    }

    /* Tooltip */
    .tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(255,255,255,0.9);
      padding: 6px 10px;
      border: 1px solid #aaa;
      border-radius: 4px;
      font-size: 24px;
      color: #333;
      display: none;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
    }

    /* Controls container */
    #controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin: 10px;
    }

    /* Large icon button */
    #play-pause {
      background: none;
      border: none;
      padding: 8px;      /* larger click area */
      cursor: pointer;
    }
    #play-pause img {
      width: 304px;       /* big icon */
      height: 170px;
      display: block;
    }

    /* Slider */
    /* #year-slider {
      width: 60%;
    } */
        /* New slider-group styling */
    .slider-group {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .slider-group label {
      font-size: 14px;
      margin-bottom: 4px;
    }
    .slider-group input {
      width: 600px;
    }
      /* style for the min/max labels under each slider */
  .slider-coords {
    display: flex;
    justify-content: space-between;
    width: 600px;   /* match the slider width */
    font-size: 12px;
    margin-top: 4px;
    color: #666;
  }
  </style>
</head>
<body>
  <div id="chart"></div>
  <div id="tooltip" class="tooltip"></div>

  <div id="controls">
    <button id="play-pause">
      <img id="play-pause-icon" src="pause.png" alt="Pause">
    </button>

    <div class="slider-group">
      <label for="start-slider">Start Year</label>
      <input type="range" id="start-slider" min="0" step="1" value="0">
      <div class="slider-coords">
        <span id="start-min">0</span>
        <span id="start-max">0</span>
      </div>
    </div>
  
    <div class="slider-group">
      <label for="end-slider">End Year</label>
      <input type="range" id="end-slider" min="0" step="1" value="0">
      <div class="slider-coords">
        <span id="end-min">0</span>
        <span id="end-max">0</span>
      </div>
    </div>
  </div>

  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script>
    const margin = { top: 50, right: 200, bottom: 30, left: 50 };
    const width  = 1800 - margin.left - margin.right;
    const height = 800 - margin.top - margin.bottom;

    const svg = d3.select('#chart')
      .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
      .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    const tooltip = d3.select('#tooltip');

    d3.csv('disney_movies_total_gross_chinese_annotated.csv', d => ({
      title:        d.movie_title,
      year:         new Date(d.release_date).getFullYear(),
      gross:        +d.total_gross.replace(/[$,]/g, ''),
      release_date: d.release_date,
      genre:        d.genre,
      mpaa:         d.MPAA_rating,
      total_gross:  d.total_gross,
      inflation_adjusted_gross:  d.inflation_adjusted_gross,
      annotation:   d.annotation   // <-- new field
    })).then(data => {
      data = data.filter(d => !isNaN(d.year) && !isNaN(d.gross));
      const years = Array.from(new Set(data.map(d => d.year))).sort((a,b)=>a-b);

      const cumulative = years.map(year=>({
        year,
        movies: data
          .filter(d=>d.year<=year)
          .sort((a,b)=>b.gross-a.gross)
          .slice(0,10)
      }));

      const maxGross = d3.max(cumulative, d=>d3.max(d.movies,m=>m.gross));
      const x = d3.scaleLinear([0,maxGross],[0,width]);
      const y = d3.scaleBand()
        .domain(d3.range(10))
        .range([0,height])
        .padding(0.1);

      // Top axis
      svg.append('g')
        .attr('class','axis')
        .call(d3.axisTop(x)
          .ticks(width/100)
          .tickFormat(d=>'$'+d3.format('.2s')(d).replace('G','B'))
        );

      const yearLabel = svg.append('text')
        .attr('class','year-text')
        .attr('x', width)
        .attr('y', height - 10)
        .text('');

      // const color = d3.scaleOrdinal(d3.schemeTableau10);
      // no explicit domain here
      const color = d3.scaleOrdinal()
      .range(d3.schemeTableau10);

      // let yearIndex = 0, isPlaying = true, interval;
      // const playButton = d3.select('#play-pause'),
      //       icon       = d3.select('#play-pause-icon');

      // playButton.on('click', () => {
      //   if (isPlaying) {
      //     stop();
      //     icon.attr('src','play.png').attr('alt','Play');
      //   } else {
      //     start();
      //     icon.attr('src','pause.png').attr('alt','Pause');
      //   }
      //   isPlaying = !isPlaying;
      // });

      // const slider = d3.select('#year-slider')
      //   .attr('max', cumulative.length-1)
      //   .on('input', function(){
      //     yearIndex = +this.value;
      //     update(cumulative[yearIndex]);
      //   });

            // ▶▶ REPLACED: dual-slider + bounded playback logic

      // Playback & interval window indices
      let startIndex = 0,
          endIndex   = cumulative.length - 1,
          current    = 0,
          isPlaying  = true,
          interval;

      // Play/Pause button
      const playButton  = d3.select('#play-pause'),
            icon        = d3.select('#play-pause-icon');

      // New sliders
      const startSlider = d3.select('#start-slider')
            .attr('max', cumulative.length - 1),
            endSlider   = d3.select('#end-slider')
            .attr('max', cumulative.length - 1)
            .property('value', cumulative.length - 1);
      
                // ② **Add the min/max labels here**:
      document.getElementById('start-min').textContent = years[0];
      document.getElementById('start-max').textContent = years[years.length - 1];
      document.getElementById('end-min')  .textContent = years[0];
      document.getElementById('end-max')  .textContent = years[years.length - 1];

      // When the user moves the start-slider…
      startSlider.on('input', function() {
        startIndex = +this.value;
        // Clamp endIndex if necessary
        if (startIndex > endIndex) {
          endIndex = startIndex;
          endSlider.property('value', endIndex);
        }
        // Jump chart to new start
        current = startIndex;
        update(cumulative[current]);
      });

      // When the user moves the end-slider…
      endSlider.on('input', function() {
        endIndex = +this.value;
        // Clamp startIndex if necessary
        if (endIndex < startIndex) {
          startIndex = endIndex;
          startSlider.property('value', startIndex);
        }
        // If we’re past the new end, rewind
        if (current > endIndex) {
          current = endIndex;
          update(cumulative[current]);
        }
      });

      // Replace your old single‐slider input handler with play/pause wiring:
      playButton.on('click', () => {
        if (isPlaying) {
          stop();
          icon.attr('src','play.png').attr('alt','Play');
        } else {
          start();
          icon.attr('src','pause.png').attr('alt','Pause');
        }
        isPlaying = !isPlaying;
      });

      // ◀◀ end replacement ◀◀


      function update(frame) {
        // ① make sure our scale only knows about *this* year’s titles
        color.domain(frame.movies.map(d => d.title));
        const t = svg.transition().duration(500),
              movies = frame.movies;

        // BARS
        const bars = svg.selectAll('.bar')
          .data(movies, d=>d.title);

        bars.exit()
          .transition(t)
          .attr('width',0)
          .remove();

        const barsEnter = bars.enter().append('rect')
          .attr('class','bar')
          .attr('x',0)
          .attr('height',y.bandwidth())
          .attr('y',(_,i)=>y(i))
          .style('fill',d=>color(d.title))
          .on('mouseover',(event,d)=>{
            tooltip.style('display','block')
                   .html(`
                     <strong>${d.title}</strong><br/>
                     出品日期: ${d.release_date}<br/>
                     类型: ${d.genre}<br/>
                     评级: ${d.mpaa||'N/A'}<br/>
                     总票房: ${d.total_gross}<br/>
                     通胀调整后票房: ${d.inflation_adjusted_gross}<br/>
                     简介: ${d.annotation}     <!-- added 简介 -->
                   `);
          })
          .on('mousemove',event=>{
            tooltip.style('left', (event.pageX+10)+'px')
                   .style('top',  (event.pageY+10)+'px');
          })
          .on('mouseout',()=>{
            tooltip.style('display','none');
          });

        // barsEnter.merge(bars)
        barsEnter.merge(bars)
          .transition(t)
          .attr('y',(_,i)=>y(i))
          .attr('width',d=>x(d.gross))
          .style('fill', d=>color(d.title));  

        // LABELS
        const labels = svg.selectAll('.label')
          .data(movies, d=>d.title);

        labels.exit().remove();

        const labelsEnter = labels.enter().append('text')
          .attr('class','label')
          .attr('y',(_,i)=>y(i)+y.bandwidth()/2+5)
          .attr('x',d=>x(d.gross)+5)
          .text(d=>`${d.title} (${d.year})`);

        labelsEnter.merge(labels)
          .transition(t)
          .attr('y',(_,i)=>y(i)+y.bandwidth()/2+5)
          .attr('x',d=>x(d.gross)+5)
          .text(d=>`${d.title} (${d.year})`);

        // YEAR TEXT
        yearLabel.transition(t).text(frame.year);

        // sync slider
        // slider.property('value', yearIndex);
      }

      // function start(){
      //   interval = d3.interval(()=>{
      //     if (yearIndex < cumulative.length-1) {
      //       yearIndex++;
      //       update(cumulative[yearIndex]);
      //     } else {
      //       stop();
      //       icon.attr('src','play.png').attr('alt','Play');
      //       isPlaying = false;
      //     }
      //   }, 1000);
      // }
      function start(){
        interval = d3.interval(()=>{
       // advance only up to endIndex
       if (current < endIndex) {
         current++;
         update(cumulative[current]);
       } else {
         stop();
         icon.attr('src','play.png').attr('alt','Play');
         isPlaying = false;
       }
     }, 1000);
   }


      function stop(){
        if (interval) interval.stop();
      }

    // init + autoplay
    update(cumulative[current]);
    start();
    })
    .catch(err=>console.error(err));
  </script>
</body>
</html>
