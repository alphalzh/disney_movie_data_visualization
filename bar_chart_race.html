<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Disney Bar‐Chart Race</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      overflow: hidden;
    }
    #chart {
      position: relative;
    }
    .bar {
      fill-opacity: 0.8;
    }
    .bar:hover {
      fill-opacity: 1;
    }
    .label {
      font-size: 12px;
      fill: #000;
      text-anchor: start;          /* Left‐anchor labels */
      pointer-events: none;
    }
    .year-text {
      font-size: 80px;
      fill: #ddd;
      text-anchor: end;
    }
    .axis .domain,
    .axis line {
      display: none;
    }
    .axis text {
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="chart"></div>

  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script>
  const margin = { top: 50, right: 200, bottom: 30, left: 50 };
  const width  = 960 - margin.left - margin.right;
  const height = 600 - margin.top - margin.bottom;

  const svg = d3.select('#chart')
    .append('svg')
      .attr('width', width + margin.left + margin.right)
      .attr('height', height + margin.top + margin.bottom)
    .append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);

  d3.csv('disney_movies_total_gross.csv', d => ({
    title: d.movie_title,
    year:  new Date(d.release_date).getFullYear(),
    gross: +d.total_gross.replace(/[$,]/g, '')
  })).then(data => {
    data = data.filter(d => !isNaN(d.year) && !isNaN(d.gross));
    const years = Array.from(new Set(data.map(d => d.year))).sort((a,b) => a - b);

    const cumulative = years.map(year => {
      const upTo = data.filter(d => d.year <= year)
                       .sort((a,b) => b.gross - a.gross)
                       .slice(0,10);
      return { year, movies: upTo };
    });

    const maxGross = d3.max(cumulative, d =>
      d3.max(d.movies, m => m.gross)
    );

    const x = d3.scaleLinear([0, maxGross], [0, width]);
    const y = d3.scaleBand()
      .domain(d3.range(10))
      .range([0, height])
      .padding(0.1);

    svg.append('g')
      .attr('class', 'axis')
      .call(d3.axisTop(x)
        .ticks(width / 100)
        .tickFormat(d => '$' + d3.format('.2s')(d).replace('G','B'))
      );

    const yearLabel = svg.append('text')
      .attr('class', 'year-text')
      .attr('x', width)
      .attr('y', height - 10)
      .text('');

    const color = d3.scaleOrdinal(d3.schemeTableau10);
    let yearIndex = 0;

    function update(frame) {
      const t = svg.transition().duration(1000);
      const movies = frame.movies;

      // --- BARS ---
      const bars = svg.selectAll('.bar')
        .data(movies, d => d.title);

      bars.exit()
        .transition(t)
        .attr('width', 0)
        .remove();

      const barsEnter = bars.enter()
        .append('rect')
          .attr('class', 'bar')
          .attr('x', 0)
          .attr('height', y.bandwidth())
          .attr('y', (_, i) => y(i))
          .style('fill', d => color(d.title));

      barsEnter.merge(bars)
        .transition(t)
          .attr('y', (_, i) => y(i))
          .attr('width', d => x(d.gross));

      // --- LABELS (outside to the right) ---
      const labels = svg.selectAll('.label')
        .data(movies, d => d.title);

      // remove any labels for movies no longer in top-10
      labels.exit().remove();

      const labelsEnter = labels.enter()
        .append('text')
          .attr('class', 'label')
          .attr('y', (_, i) => y(i) + y.bandwidth() / 2 + 5)
          .attr('x', d => x(d.gross) + 5)              // 5px to right of bar
          .text(d => `${d.title} (${d.year})`);

      labelsEnter.merge(labels)
        .transition(t)
          .attr('y', (_, i) => y(i) + y.bandwidth() / 2 + 5)
          .attr('x', d => x(d.gross) + 5)
          .text(d => `${d.title} (${d.year})`);

      // --- YEAR TEXT ---
      yearLabel.transition(t)
        .text(frame.year);
    }

    update(cumulative[0]);
    const interval = d3.interval(() => {
      yearIndex++;
      if (yearIndex >= cumulative.length) {
        interval.stop();
      } else {
        update(cumulative[yearIndex]);
      }
    }, 1000);
  })
  .catch(err => console.error(err));
  </script>
</body>
</html>
